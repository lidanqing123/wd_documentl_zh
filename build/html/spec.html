

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>完整规范 &mdash; WDL_document_zh 0.1.1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> WDL_document_zh
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">WDL User Guide:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quick/quickstart.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick/structure.html">基础结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick/variables.html">添加变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick/plumbing.html">添加管道</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorials/index.html">WDL 教程</a></li>
</ul>
<p class="caption"><span class="caption-text">Supplement:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="supplement/plumbing_options.html">Plumbing Options</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">WDL_document_zh</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>完整规范</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/spec.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>完整规范<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>The WDL specification featured below lives here in the WDL Github repository. We have some plans to clean up formatting, rewrite some sections to improve accuracy and also add versioning. When the updated spec documentation is ready, we will post an announcement on the blog. In the meantime, we thank you for your patience and we encourage you to ask questions in the forum.</p>
<p>Note that currently the table of contents linking does not work on this page; we will fix that soon.
Workflow Description Language
Table Of Contents</p>
<blockquote>
<div><dl class="docutils">
<dt>Workflow Description Language</dt>
<dd>Table Of Contents
Introduction
State of the Specification</dd>
<dt>Language Specification</dt>
<dd><dl class="first docutils">
<dt>Global Grammar Rules</dt>
<dd>Whitespace, Strings, Identifiers, Constants
Types
Fully Qualified Names &amp; Namespaced Identifiers
Declarations
Expressions
Operator Precedence Table
Member Access
Map and Array Indexing
Pair Indexing
Function Calls
Array Literals
Map Literals
Pair Literals</dd>
</dl>
<p>Document
Import Statements
Task Definition</p>
<blockquote>
<div><p>Sections
Command Section</p>
<blockquote>
<div><p>Command Parts
Command Part Options</p>
<blockquote>
<div>sep
true and false
default</div></blockquote>
<p>Alternative heredoc syntax
Stripping Leading Whitespace</p>
</div></blockquote>
<p>Outputs Section
String Interpolation
Runtime Section</p>
<blockquote>
<div>docker
memory</div></blockquote>
<p>Parameter Metadata Section
Metadata Section
Examples</p>
<blockquote>
<div>Example 1: Simplest Task
Example 2: Inputs/Outputs
Example 3: Runtime/Metadata
Example 4: BWA mem
Example 5: Word Count
Example 6: tmap</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>Workflow Definition</dt>
<dd><dl class="first docutils">
<dt>Call Statement</dt>
<dd>Sub Workflows</dd>
</dl>
<p class="last">Scatter
Loops
Conditionals
Parameter Metadata
Metadata
Outputs</p>
</dd>
</dl>
</dd>
</dl>
<p>Namespaces
Scope
Optional Parameters &amp; Type Constraints</p>
<blockquote>
<div>Prepending a String to an Optional Parameter</div></blockquote>
<p>Scatter / Gather
Variable Resolution</p>
<blockquote>
<div>Task-Level Resolution
Workflow-Level Resolution</div></blockquote>
<dl class="docutils">
<dt>Computing Inputs</dt>
<dd>Task Inputs
Workflow Inputs
Specifying Workflow Inputs in JSON</dd>
</dl>
<p>Type Coercion
Standard Library</p>
<blockquote>
<div>File stdout()
File stderr()
Array[String] read_lines(String|File)
Array[Array[String]] read_tsv(String|File)
Map[String, String] read_map(String|File)
Object read_object(String|File)
Array[Object] read_objects(String|File)
mixed read_json(String|File)
Int read_int(String|File)
String read_string(String|File)
Float read_float(String|File)
Boolean read_boolean(String|File)
File write_lines(Array[String])
File write_tsv(Array[Array[String]])
File write_map(Map[String, String])
File write_object(Object)
File write_objects(Array[Object])
File write_json(mixed)
Float size(File, [String])
String sub(String, String, String)
Array[Int] range(Int)
Array[Array[X]] transpose(Array[Array[X]])
Array[Pair(X,Y)] zip(Array[X], Array[Y])
Array[Pair(X,Y)] cross(Array[X], Array[Y])
Integer length(Array[X])
Array[String] prefix(String, Array[X])
X select_first(Array[X?])
Array[X] select_all(Array[X?])
Boolean defined(X?)
String basename(String)
Int floor(Float), Int ceil(Float) and Int round(Float)</div></blockquote>
<dl class="docutils">
<dt>Data Types &amp; Serialization</dt>
<dd><dl class="first last docutils">
<dt>Serialization of Task Inputs</dt>
<dd><p class="first">Primitive Types
Compound Types</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Array serialization</dt>
<dd>Array serialization by expansion
Array serialization using write_lines()
Array serialization using write_json()</dd>
<dt>Map serialization</dt>
<dd>Map serialization using write_map()
Map serialization using write_json()</dd>
<dt>Object serialization</dt>
<dd>Object serialization using write_object()
Object serialization using write_json()</dd>
<dt>Array[Object] serialization</dt>
<dd>Array[Object] serialization using write_objects()
Array[Object] serialization using write_json()</dd>
</dl>
</div></blockquote>
</dd>
<dt>De-serialization of Task Outputs</dt>
<dd><p class="first">Primitive Types
Compound Types</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Array deserialization</dt>
<dd>Array deserialization using read_lines()
Array deserialization using read_json()</dd>
<dt>Map deserialization</dt>
<dd>Map deserialization using read_map()
Map deserialization using read_json()</dd>
<dt>Object deserialization</dt>
<dd>Object deserialization using read_object()</dd>
<dt>Array[Object] deserialization</dt>
<dd>Object deserialization using read_objects()</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Introduction</p>
<p>WDL is meant to be a human readable and writable way to express tasks and workflows. The “Hello World” tool in WDL would look like this:</p>
<dl class="docutils">
<dt>task hello {</dt>
<dd><p class="first">String pattern
File in</p>
<dl class="docutils">
<dt>command {</dt>
<dd>egrep ‘${pattern}’ ‘${in}’</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>runtime {</dt>
<dd>docker: “broadinstitute/my_image”</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Array[String] matches = read_lines(stdout())</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd>call hello</dd>
</dl>
<p>}</p>
<p>This describes a task, called ‘hello’, which has two parameters (String pattern and File in). A task definition is a way of encapsulating a UNIX command and environment and presenting them as functions. Tasks have both inputs and outputs. Inputs are declared as declarations at the top of the task definition, while outputs are defined in the output section.</p>
<p>The user must provide a value for these two parameters in order for this task to be runnable. Implementations of WDL should accept their inputs as JSON format. For example, the above task needs values for two parameters: String pattern and File in:
Variable        Value
wf.hello.pattern        ^[a-z]+$
wf.hello.in     /file.txt</p>
<p>Or, in JSON format:</p>
<dl class="docutils">
<dt>{</dt>
<dd>“wf.hello.pattern”: “^[a-z]+$”,
“wf.hello.in”: “/file.txt”</dd>
</dl>
<p>}</p>
<p>Running the wf workflow with these parameters would yield a command line from the call hello:</p>
<p>egrep ‘^[a-z]+$’ ‘/file.txt’</p>
<p>A simple workflow that runs this task in parallel would look like this:</p>
<dl class="docutils">
<dt>workflow example {</dt>
<dd><p class="first">Array[File] files
scatter(path in files) {</p>
<blockquote>
<div>call hello {input: in=path}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>The inputs to this workflow would be example.files and example.hello.pattern.
State of the Specification</p>
<p>17 August 2015</p>
<blockquote>
<div><p>Added concept of fully-qualified-name as well as namespace identifier.
Changed task definitions to have all inputs as declarations.
Changed command parameters (${…}) to accept expressions and fewer “declarative” elements</p>
<blockquote>
<div>command parameters also are required to evaluate to primitive types</div></blockquote>
<p>Added a output section to workflows
Added a lot of functions to the standard library for serializing/deserializing WDL values
Specified scope, namespace, and variable resolution semantics</p>
</div></blockquote>
<p>Language Specification
Global Grammar Rules
Whitespace, Strings, Identifiers, Constants</p>
<p>🐖 Cromwell supported ✅</p>
<p>These are common among many of the following sections</p>
<p>$ws = (0x20 | 0x9 | 0xD | 0xA)+
$identifier = [a-zA-Z][<a href="#id4"><span class="problematic" id="id5">a-zA-Z0-9_</span></a>]+
$string = “([^&quot;n]|\[&quot;’nrbtfav?]|\[0-7]{1,3}|\x[0-9a-fA-F]+|\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*”
$string = ‘([^'n]|\[&quot;’nrbtfav?]|\[0-7]{1,3}|\x[0-9a-fA-F]+|\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*’
$boolean = ‘true’ | ‘false’
$integer = [1-9][0-9]*|0[xX][0-9a-fA-F]+|0[0-7]*
$float = (([0-9]+)?.([0-9]+)|[0-9]+.|[0-9]+)([eE][-+]?[0-9]+)?</p>
<p>$string can accept the following between single or double-quotes:</p>
<blockquote>
<div>Any character not in set: \, ” (or ‘ for single-quoted string), n
An escape sequence starting with \, followed by one of the following characters: \, “, ‘, [nrbtfav], ?
An escape sequence starting with \, followed by 1 to 3 digits of value 0 through 7 inclusive. This specifies an octal escape code.
An escape sequence starting with \x, followed by hexadecimal characters 0-9a-fA-F. This specifies a hexidecimal escape code.
An escape sequence starting with \u or \U followed by either 4 or 8 hexadecimal characters 0-9a-fA-F. This specifies a unicode code point</div></blockquote>
<p>Types</p>
<p>🐖 Cromwell supported ✅</p>
<p>All inputs and outputs must be typed.</p>
<p>$type = ($primitive_type | $array_type | $map_type | $object_type) $type_postfix_quantifier?
$primitive_type = (‘Boolean’ | ‘Int’ | ‘Float’ | ‘File’ | ‘String’)
$array_type = ‘Array’ ‘[‘ ($primitive_type | $object_type | $array_type) ‘]’
$object_type = ‘Object’
$map_type = ‘Map’ ‘[‘ $primitive_type ‘,’ ($primitive_type | $array_type | $map_type | $object_type) ‘]’
$type_postfix_quantifier = ‘?’ | ‘+’</p>
<p>Some examples of types:</p>
<blockquote>
<div>File
Array[File]
Map[String, String]
Object</div></blockquote>
<p>Types can also have a $type_postfix_quantifier (either ? or +):</p>
<blockquote>
<div>? means that the value is optional. Any expressions that fail to evaluate because this value is missing will evaluate to the empty string.
+ can only be applied to Array types, and it signifies that the array is required to have one or more values in it</div></blockquote>
<p>For more details on the $type_postfix_quantifier, see the section on Optional Parameters &amp; Type Constraints</p>
<p>For more information on type and how they are used to construct commands and define outputs of tasks, see the Data Types &amp; Serialization section.
Fully Qualified Names &amp; Namespaced Identifiers</p>
<p>🐖 Cromwell supported ✅</p>
<p>$fully_qualified_name = $identifier (‘.’ $identifier)*
$namespaced_identifier = $identifier (‘.’ $identifier)*</p>
<p>A fully qualified name is the unique identifier of any particular call or call input or output. For example:</p>
<p>other.wdl</p>
<dl class="docutils">
<dt>task foobar {</dt>
<dd><p class="first">File in
command {</p>
<blockquote>
<div>sh setup.sh ${in}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>File results = stdout()</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>main.wdl</p>
<p>import “other.wdl” as other</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">String my_var
command {</p>
<blockquote>
<div>./script ${my_var}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>File results = stdout()</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Array[String] arr = [“a”, “b”, “c”]
call test
call test as test2
call other.foobar
output {</p>
<blockquote>
<div>test.results
foobar.results</div></blockquote>
<p>}
scatter(x in arr) {</p>
<blockquote>
<div><dl class="docutils">
<dt>call test as scattered_test {</dt>
<dd>input: my_var=x</dd>
</dl>
<p>}</p>
</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>The following fully-qualified names would exist within workflow wf in main.wdl:</p>
<blockquote>
<div>wf - References top-level workflow
wf.test - References the first call to task test
wf.test2 - References the second call to task test (aliased as test2)
wf.test.my_var - References the String input of first call to task test
wf.test.results - References the File output of first call to task test
wf.test2.my_var - References the String input of second call to task test
wf.test2.results - References the File output of second call to task test
wf.foobar.results - References the File output of the call to other.foobar
wf.foobar.input - References the File input of the call to other.foobar
wf.arr - References the Array[String] declaration on the workflow
wf.scattered_test - References the scattered version of call test
wf.scattered_test.my_var - References an Array[String] for each element used as my_var when running the scattered version of call test.
wf.scattered_test.results - References an Array[File] which are the accumulated results from scattering call test
wf.scattered_test.1.results - References an File from the second invocation (0-indexed) of call test within the scatter block. This particular invocation used value “b” for my_var</div></blockquote>
<p>A namespaced identifier has the same syntax as a fully-qualified name. It is interpreted as the left-hand side being the name of a namespace and then the right-hand side being the name of a workflow, task, or namespace within that namespace. Consider this workflow:</p>
<p>import “other.wdl” as ns
workflow wf {</p>
<blockquote>
<div>call ns.ns2.task</div></blockquote>
<p>}</p>
<p>Here, ns.ns2.task is a namespace identifier (see the Call Statement section for more details). Namespace identifiers, like fully-qualified names are left-associative, which means ns.ns2.task is interpreted as ((ns.ns2).task), which means ns.ns2 would have to resolve to a namespace so that .task could be applied. If ns2 was a task definition within ns, then this namespaced identifier would be invalid.
Declarations</p>
<p>🐖 Cromwell supported ✅</p>
<p>$declaration = $type $identifier (‘=’ $expression)?</p>
<p>Declarations are declared at the top of any scope.</p>
<p>In a task definition, declarations are interpreted as inputs to the task that are not part of the command line itself.</p>
<p>If a declaration does not have an initialization, then the value is expected to be provided by the user before the workflow or task is run.</p>
<p>Some examples of declarations:</p>
<blockquote>
<div>File x
String y = “abc”
Float pi = 3 + .14
Map[String, String] m</div></blockquote>
<p>A declaration may also refer to elements that are outputs of tasks. For example:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">String var
command {</p>
<blockquote>
<div>./script ${var}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>String value = read_string(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>task test2 {</dt>
<dd><p class="first">Array[String] array
command {</p>
<blockquote>
<div>./script ${write_lines(array)}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Int value = read_int(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd>call test as x {input: var=”x”}
call test as y {input: var=”y”}
Array[String] strs = [x.value, y.value]
call test2 as z {input: array=strs}</dd>
</dl>
<p>}</p>
<p>strs in this case would not be defined until both call test as x and call test as y have successfully completed. Before that’s the case, strs is undefined. If any of the two tasks fail, then evaluation of strs should return an error to indicate that the call test2 as z operation should be skipped.
Expressions</p>
<p>🐖 Cromwell supported ✅</p>
<p>$expression = ‘(‘ $expression ‘)’
$expression = $expression ‘.’ $expression
$expression = $expression ‘[‘ $expression ‘]’
$expression = $expression ‘(‘ ($expression (‘,’ $expression)*)? ‘)’
$expression = ‘!’ $expression
$expression = ‘+’ $expression
$expression = ‘-‘ $expression
$expression = if $expression then $expression else $expression
$expression = $expression ‘*’ $expression
$expression = $expression ‘%’ $expression
$expression = $expression ‘/’ $expression
$expression = $expression ‘+’ $expression
$expression = $expression ‘-‘ $expression
$expression = $expression ‘&lt;’ $expression
$expression = $expression ‘=&lt;’ $expression
$expression = $expression ‘&gt;’ $expression
$expression = $expression ‘&gt;=’ $expression
$expression = $expression ‘==’ $expression
$expression = $expression ‘!=’ $expression
$expression = $expression ‘&amp;&amp;’ $expression
$expression = $expression ‘||’ $expression
$expression = ‘{‘ ($expression ‘:’ $expression)* ‘}’
$expression = ‘[‘ $expression* ‘]’
$expression = $string | $integer | $float | $boolean | $identifier</p>
<p>Below are the valid results for operators on types. Any combination not in the list will result in an error.
LHS Type        Operators       RHS Type        Result  Semantics
Boolean         ==      Boolean         Boolean
Boolean         !=      Boolean         Boolean
Boolean         &gt;       Boolean         Boolean
Boolean         &gt;=      Boolean         Boolean
Boolean         &lt;       Boolean         Boolean
Boolean         &lt;=      Boolean         Boolean
Boolean         `               `       Boolean
Boolean         &amp;&amp;      Boolean         Boolean
File    +       File    File    Append file paths
File    ==      File    Boolean
File    !=      File    Boolean
File    +       String  File
File    ==      String  Boolean
File    !=      String  Boolean
Float   +       Float   Float
Float   -       Float   Float
Float   *       Float   Float
Float   /       Float   Float
Float   %       Float   Float
Float   ==      Float   Boolean
Float   !=      Float   Boolean
Float   &gt;       Float   Boolean
Float   &gt;=      Float   Boolean
Float   &lt;       Float   Boolean
Float   &lt;=      Float   Boolean
Float   +       Int     Float
Float   -       Int     Float
Float   *       Int     Float
Float   /       Int     Float
Float   %       Int     Float
Float   ==      Int     Boolean
Float   !=      Int     Boolean
Float   &gt;       Int     Boolean
Float   &gt;=      Int     Boolean
Float   &lt;       Int     Boolean
Float   &lt;=      Int     Boolean
Float   +       String  String
Int     +       Float   Float
Int     -       Float   Float
Int     *       Float   Float
Int     /       Float   Float
Int     %       Float   Float
Int     ==      Float   Boolean
Int     !=      Float   Boolean
Int     &gt;       Float   Boolean
Int     &gt;=      Float   Boolean
Int     &lt;       Float   Boolean
Int     &lt;=      Float   Boolean
Int     +       Int     Int
Int     -       Int     Int
Int     *       Int     Int
Int     /       Int     Int     Integer division
Int     %       Int     Int     Integer division, return remainder
Int     ==      Int     Boolean
Int     !=      Int     Boolean
Int     &gt;       Int     Boolean
Int     &gt;=      Int     Boolean
Int     &lt;       Int     Boolean
Int     &lt;=      Int     Boolean
Int     +       String  String
String  +       Float   String
String  +       Int     String
String  +       String  String
String  ==      String  Boolean
String  !=      String  Boolean
String  &gt;       String  Boolean
String  &gt;=      String  Boolean
String  &lt;       String  Boolean
String  &lt;=      String  Boolean</p>
<blockquote>
<div><ul class="simple">
<li>Float   Float</li>
</ul>
<ul class="simple">
<li>Float   Float</li>
</ul>
<ul class="simple">
<li>Int     Int</li>
</ul>
<ul class="simple">
<li>Int     Int</li>
</ul>
<p>!       Boolean         Boolean</p>
</div></blockquote>
<p>If then else</p>
<p>This is an operator that takes three arguments, a condition expression, an if-true expression and an if-false expression. The condition is always evaluated. If the condition is true then the if-true value is evaluated and returned. If the condition is false, the if-false expression is evaluated and returned. The return type of the if-then-else should be the same, regardless of which side is evaluated or runtime problems might occur.</p>
<p>Examples:</p>
<blockquote>
<div>Choose whether to say “good morning” or “good afternoon”:</div></blockquote>
<p>Boolean morning = …
String greeting = “good ” + if morning then “morning” else “afternoon”</p>
<blockquote>
<div>Choose how much memory to use for a task:</div></blockquote>
<p>Int array_length = length(array)
runtime {</p>
<blockquote>
<div>memory: if array_length &gt; 100 then “16GB” else “8GB”</div></blockquote>
<p>}</p>
<p>Operator Precedence Table</p>
<p>🐖 Cromwell supported ✅
Precedence      Operator type   Associativity   Example
12      Grouping        n/a     (x)
11      Member Access   left-to-right   x.y
10      Index   left-to-right   x[y]
9       Function Call   left-to-right   x(y,z,…)
8       Logical NOT     right-to-left   !x</p>
<blockquote>
<div>Unary Plus      right-to-left   +x
Unary Negation  right-to-left   -x</div></blockquote>
<dl class="docutils">
<dt>7       Multiplication  left-to-right   x*y</dt>
<dd>Division        left-to-right   x/y
Remainder       left-to-right   x%y</dd>
<dt>6       Addition        left-to-right   x+y</dt>
<dd>Subtraction     left-to-right   x-y</dd>
<dt>5       Less Than       left-to-right   x&lt;y</dt>
<dd>Less Than Or Equal      left-to-right   x&lt;=y
Greater Than    left-to-right   x&gt;y
Greater Than Or Equal   left-to-right   x&gt;=y</dd>
<dt>4       Equality        left-to-right   x==y</dt>
<dd>Inequality      left-to-right   x!=y</dd>
</dl>
<p>3       Logical AND     left-to-right   x&amp;&amp;y
2       Logical OR      left-to-right   x||y
1       Assignment      right-to-left   x=y
Member Access</p>
<p>🐖 Cromwell supported ✅</p>
<p>The syntax x.y refers to member access. x must be an object or task in a workflow. A Task can be thought of as an object where the attributes are the outputs of the task.</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Object obj
Object foo</p>
<p># This would cause a syntax error,
# because foo is defined twice in the same namespace.
call foo {</p>
<blockquote>
<div>input: var=obj.attr # Object attribute</div></blockquote>
<p>}</p>
<dl class="docutils">
<dt>call foo as foo2 {</dt>
<dd>input: var=foo.out # Task output</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Map and Array Indexing</p>
<p>🐖 Cromwell supported ✅</p>
<p>The syntax x[y] is for indexing maps and arrays. If x is an array, then y must evaluate to an integer. If x is a map, then y must evaluate to a key in that map.
Pair Indexing</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a Pair x, the left and right elements of that type can be accessed using the syntax x.left and x.right.
Function Calls</p>
<p>🐖 Cromwell supported ✅</p>
<p>Function calls, in the form of func(p1, p2, p3, …), are either standard library functions or engine-defined functions.</p>
<p>In this current iteration of the spec, users cannot define their own functions.
Array Literals</p>
<p>🐖 Cromwell supported ✅</p>
<p>Arrays values can be specified using Python-like syntax, as follows:</p>
<p>Array[String] a = [“a”, “b”, “c”]
Array[Int] b = [0,1,2]</p>
<p>Map Literals</p>
<p>🐖 Cromwell supported ✅</p>
<p>Maps values can be specified using a similar Python-like sytntax:</p>
<p>Map[Int, Int] = {1: 10, 2: 11}
Map[String, Int] = {“a”: 1, “b”: 2}</p>
<p>Pair Literals</p>
<p>🐖 Cromwell supported ✅</p>
<p>Pair values can be specified inside of a WDL using another Python-like syntax, as follows:</p>
<p>Pair[Int, String] twenty_threes = (23, “twenty-three”)</p>
<p>Pair values can also be specified within the workflow inputs JSON with a Left and Right value specified using JSON style syntax. For example, given a workflow wf_hello and workflow-level variable twenty_threes, it could be declared in the workflow inputs JSON as follows:</p>
<dl class="docutils">
<dt>{</dt>
<dd>“wf_hello.twenty_threes”: { “Left”: 23, “Right”: “twenty-three” }</dd>
</dl>
<p>}</p>
<p>Document</p>
<p>🐖 Cromwell supported ✅</p>
<p>$document = ($import | $task | $workflow)+</p>
<p>$document is the root of the parse tree and it consists of one or more import statement, task, or workflow definition
Import Statements</p>
<p>🐖 Coming soon in Cromwell</p>
<p>A WDL file may contain import statements to include WDL code from other sources</p>
<p>$import = ‘import’ $ws+ $string ($ws+ ‘as’ $ws+ $identifier)?</p>
<p>The import statement specifies that $string which is to be interpted as a URI which points to a WDL file. The engine is responsible for resolving the URI and downloading the contents. The contents of the document in each URI must be WDL source code.</p>
<p>Every imported WDL file requires a namespace which can be specified using an identifier (via the as $identifier syntax). If you do not explicitly specify a namespace identifier then the default namespace is the filename of the imported WDL, minus the .wdl extension. For all imported WDL files, the tasks and workflows imported from that file will only be accessible through that assigned namespace.</p>
<p>import “<a class="reference external" href="http://example.com/lib/analysis_tasks">http://example.com/lib/analysis_tasks</a>” as analysis
import “<a class="reference external" href="http://example.com/lib/stdlib">http://example.com/lib/stdlib</a>”</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">File bam_file</p>
<p># file_size is from “<a class="reference external" href="http://example.com/lib/stdlib">http://example.com/lib/stdlib</a>”
call stdlib.file_size {</p>
<blockquote>
<div>input: file=bam_file</div></blockquote>
<p>}
call analysis.my_analysis_task {</p>
<blockquote>
<div>input: size=file_size.bytes, file=bam_file</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Engines should at the very least support the following protocols for import URIs:</p>
<blockquote>
<div><a class="reference external" href="http://">http://</a> and <a class="reference external" href="https://">https://</a>
<a class="reference external" href="file://">file://</a>
no protocol (which should be interpreted as <a class="reference external" href="file://">file://</a></div></blockquote>
<p>Task Definition</p>
<p>🐖 Cromwell supported ✅</p>
<p>A task is a declarative construct with a focus on constructing a command from a template. The command specification is interpreted in an engine specific way, though a typical case is that a command is a UNIX command line which would be run in a Docker image.</p>
<p>Tasks also define their outputs, which is essential for building dependencies between tasks. Any other data specified in the task definition (e.g. runtime information and meta-data) is optional.</p>
<p>$task = ‘task’ $ws+ $identifier $ws* ‘{‘ $ws* $declaration* $task_sections $ws* ‘}’</p>
<p>For example, task name { … }. Inside the curly braces defines the sections.
Sections</p>
<p>🐖 Cromwell supported ✅</p>
<p>The task has one or more sections:</p>
<p>$task_sections = ($command | $runtime | $task_output | $parameter_meta | $meta)+</p>
<blockquote>
<div>Additional requirement: Exactly one $command section needs to be defined, preferably as the first section.</div></blockquote>
<p>Command Section</p>
<p>🐖 Cromwell supported ✅</p>
<p>$command = ‘command’ $ws* ‘{‘ (0xA | 0xD)* $command_part+ $ws+ ‘}’
$command = ‘command’ $ws* ‘&lt;&lt;&lt;’ (0xA | 0xD)* $command_part+ $ws+ ‘&gt;&gt;&gt;’</p>
<p>A command is a task section that starts with the keyword ‘command’, and is enclosed in curly braces or &lt;&lt;&lt; &gt;&gt;&gt;. The body of the command specifies the literal command line to run with placeholders ($command_part_var) for the parts of the command line that needs to be filled in.
Command Parts</p>
<p>🐖 Cromwell supported ✅</p>
<p>$command_part = $command_part_string | $command_part_var
$command_part_string = ^’${‘+
$command_part_var = ‘${‘ $var_option* $expression ‘}’</p>
<p>The parser should read characters from the command line until it reaches a ${ character sequence. This is interpreted as a literal string ($command_part_string).</p>
<p>The parser should interpret any variable enclosed in ${…} as a $command_part_var.</p>
<p>The $expression usually references declarations at the task level. For example:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">String flags
command {</p>
<blockquote>
<div>ps ${flags}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>In this case flags within the ${…} is an expression. The $expression can also be more complex, like a function call: write_lines(some_array_value)</p>
<blockquote>
<div>NOTE: the $expression in this context can only evaluate to a primitive type (e.g. not Array, Map, or Object). The only exception to this rule is when sep is specified as one of the $var_option fields</div></blockquote>
<p>As another example, consider how the parser would parse the following command:</p>
<p>grep ‘${start}…${end}’ ${input}</p>
<p>This command would be parsed as:</p>
<blockquote>
<div>grep ‘ - command_part_string
${start} - command_part_var
… - command_part_string
${end} - command_part_var
‘ - command_part_string
${input} - command_part_var</div></blockquote>
<p>Command Part Options</p>
<p>🐖 Cromwell supported ✅</p>
<p>$var_option = $var_option_key $ws* ‘=’ $ws* $var_option_value
$var_option_key = ‘sep’ | ‘true’ | ‘false’ | ‘quote’ | ‘default’
$var_option_value = $expression</p>
<p>The $var_option is a set of key-value pairs for any additional and less-used options that need to be set on a parameter.
sep</p>
<p>🐖 Cromwell supported ✅</p>
<p>‘sep’ is interpreted as the separator string used to join multiple parameters together. sep is only valid if the expression evaluates to an Array.</p>
<p>For example, if there were a declaration Array[Int] ints = [1,2,3], the command python script.py ${sep=’,’ numbers} would yield the command line:</p>
<p>python script.py 1,2,3</p>
<p>Alternatively, if the command were python script.py ${sep=’ ‘ numbers} it would parse to:</p>
<p>python script.py 1 2 3</p>
<blockquote>
<div><p>Additional Requirements:</p>
<blockquote>
<div>sep MUST accept only a string as its value</div></blockquote>
</div></blockquote>
<p>true and false</p>
<p>🐖 Cromwell supported ✅</p>
<p>‘true’ and ‘false’ are only used for type Boolean and they specify what the parameter returns when the Boolean is true or false, respectively.</p>
<p>For example, ${true=’–enable-foo’, false=’–disable-foo’ Boolean yes_or_no} would evaluate to either –enable-foo or –disable-foo based on the value of yes_or_no.</p>
<p>If either value is left out, then it’s equivalent to specifying the empty string. If the parameter is ${true=’–enable-foo’ Boolean yes_or_no}, and a value of false is specified for this parameter, then the parameter will evaluate to the empty string.</p>
<blockquote>
<div><p>Additional Requirement:</p>
<blockquote>
<div>true and false values MUST be strings.
true and false are only allowed if the type is Boolean</div></blockquote>
</div></blockquote>
<p>default</p>
<p>🐖 Cromwell supported ✅</p>
<p>This specifies the default value if no other value is specified for this parameter.</p>
<dl class="docutils">
<dt>task default_test {</dt>
<dd><p class="first">String? s
command {</p>
<blockquote>
<div>./my_cmd ${default=”foobar” s}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>This task takes an optional String parameter and if a value is not specified, then the value of foobar will be used instead.</p>
<blockquote>
<div><p>Additional Requirements:</p>
<blockquote>
<div>The type of the expression must match the type of the parameter
If ‘default’ is specified, the $type_postfix_quantifier for the variable’s type MUST be ?</div></blockquote>
</div></blockquote>
<p>Alternative heredoc syntax</p>
<p>🐖 Cromwell supported ✅</p>
<p>Sometimes a command is sufficiently long enough or might use { characters that using a different set of delimiters would make it more clear. In this case, enclose the command in &lt;&lt;&lt;…&gt;&gt;&gt;, as follows:</p>
<dl class="docutils">
<dt>task heredoc {</dt>
<dd><p class="first">File in</p>
<p>command&lt;&lt;&lt;
python &lt;&lt;CODE</p>
<blockquote>
<div><dl class="docutils">
<dt>with open(“${in}”) as fp:</dt>
<dd><dl class="first last docutils">
<dt>for line in fp:</dt>
<dd><dl class="first last docutils">
<dt>if not line.startswith(‘#’):</dt>
<dd>print(line.strip())</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p class="last">CODE
&gt;&gt;&gt;</p>
</dd>
</dl>
<p>}</p>
<p>Parsing of this command should be the same as the prior section describes.
Stripping Leading Whitespace</p>
<p>🐖 Cromwell supported ✅</p>
<p>Any text inside of the command section, after instantiated, should have all common leading whitespace removed. In the task heredoc example in the previous section, if the user specifies a value of /path/to/file as the value for File in, then the command should be:</p>
<dl class="docutils">
<dt>python &lt;&lt;CODE</dt>
<dd><dl class="first last docutils">
<dt>with open(“/path/to/file”) as fp:</dt>
<dd><dl class="first last docutils">
<dt>for line in fp:</dt>
<dd><dl class="first last docutils">
<dt>if not line.startswith(‘#’):</dt>
<dd>print(line.strip())</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>CODE</p>
<p>The 2-spaces that were common to each line were removed.</p>
<p>If the user mixes tabs and spaces, the behavior is undefined. A warning is suggested, and perhaps a convention of 4 spaces per tab. Other implementations might return an error in this case.
Outputs Section</p>
<p>🐖 Cromwell supported ✅</p>
<p>The outputs section defines which of the files and values should be exported after a successful run of this tool.</p>
<p>$task_output = ‘output’ $ws* ‘{‘ ($ws* $task_output_kv $ws*)* ‘}’
$task_output_kv = $type $identifier $ws* ‘=’ $ws* $string</p>
<p>The outputs section contains typed variable definitions and a binding to the variable that they export.</p>
<p>The left-hand side of the equality defines the type and name of the output.</p>
<p>The right-hand side defines the path to the file that contains that variable definition.</p>
<p>For example, if a task’s output section looks like this:</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Int threshold = read_int(“threshold.txt”)</dd>
</dl>
<p>}</p>
<p>Then the task is expecting a file called “threshold.txt” in the current working directory where the task was executed. Inside of that file must be one line that contains only an integer and whitespace. See the Data Types &amp; Serialization section for more details.</p>
<p>The filename strings may also contain variable definitions themselves (see the String Interpolation section below for more details):</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Array[String] quality_scores = read_lines(“${sample_id}.scores.txt”)</dd>
</dl>
<p>}</p>
<p>If this is the case, then sample_id is considered an input to the task.</p>
<p>As with inputs, the outputs can reference previous outputs in the same block. The only requirement is that the output being referenced must be specified before the output which uses it.</p>
<dl class="docutils">
<dt>output {</dt>
<dd>String a = “a”
String ab = a + “b”</dd>
</dl>
<p>}</p>
<p>Globs can be used to define outputs which contain many files. The glob function generates an array of File outputs:</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Array[File] output_bams = glob(“<a href="#id2"><span class="problematic" id="id3">*</span></a>.bam”)</dd>
</dl>
<p>}</p>
<p>String Interpolation</p>
<p>🐖 Cromwell supported ✅</p>
<p>Within tasks, any string literal can use string interpolation to access the value of any of the task’s inputs. The most obvious example of this is being able to define an output file which is named as function of its input. For example:</p>
<dl class="docutils">
<dt>task example {</dt>
<dd><p class="first">String prefix
File bam
command {</p>
<blockquote>
<div>python analysis.py –prefix=${prefix} ${bam}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>File analyzed = “${prefix}.out”
File bam_sibling = “${bam}.suffix”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Any ${identifier} inside of a string literal must be replaced with the value of the identifier. If prefix were specified as foobar, then “${prefix}.out” would be evaluated to “foobar.out”.
Runtime Section</p>
<p>🐖 Cromwell supported ✅</p>
<p>$runtime = ‘runtime’ $ws* ‘{‘ ($ws* $runtime_kv $ws*)* ‘}’
$runtime_kv = $identifier $ws* ‘=’ $ws* $expression</p>
<p>The runtime section defines key/value pairs for runtime information needed for this task. Individual backends will define which keys they will inspect so a key/value pair may or may not actually be honored depending on how the task is run.</p>
<p>Values can be any expression and it is up to the engine to reject keys and/or values that do not make sense in that context. For example, consider the following WDL:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command {</dt>
<dd>python script.py</dd>
</dl>
<p>}
runtime {</p>
<blockquote>
<div>docker: [“ubuntu:latest”, “broadinstitute/scala-baseimage”]</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>The value for the docker runtime attribute in this case is an array of values. The parser should accept this. Some engines might interpret it as an “either this image or that image” or could reject it outright.</p>
<p>Since values are expressions, they can also reference variables in the task:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">String ubuntu_version</p>
<dl class="docutils">
<dt>command {</dt>
<dd>python script.py</dd>
</dl>
<p>}
runtime {</p>
<blockquote>
<div>docker: “ubuntu:” + ubuntu_version</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Most key/value pairs are arbitrary. However, the following keys have recommended conventions:
docker</p>
<p>🐖 Cromwell supported ✅</p>
<p>Location of a Docker image for which this task ought to be run. This can have a format like ubuntu:latest or broadinstitute/scala-baseimage in which case it should be interpreted as an image on DockerHub (i.e. it is valid to use in a docker pull command).</p>
<dl class="docutils">
<dt>task docker_test {</dt>
<dd><p class="first">String arg</p>
<dl class="docutils">
<dt>command {</dt>
<dd>python process.py ${arg}</dd>
</dl>
<p>}
runtime {</p>
<blockquote>
<div>docker: “ubuntu:latest”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>memory</p>
<p>🐖 Cromwell supported ✅</p>
<p>Memory requirements for this task. Two kinds of values are supported for this attributes:</p>
<blockquote>
<div>Int - Intepreted as bytes
String - This should be a decimal value with suffixes like B, KB, MB or binary suffixes KiB, MiB. For example: 6.2 GB, 5MB, 2GiB.</div></blockquote>
<dl class="docutils">
<dt>task memory_test {</dt>
<dd><p class="first">String arg</p>
<dl class="docutils">
<dt>command {</dt>
<dd>python process.py ${arg}</dd>
</dl>
<p>}
runtime {</p>
<blockquote>
<div>memory: “2GB”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Parameter Metadata Section</p>
<p>🐖 Cromwell supported ✅</p>
<p>$parameter_meta = ‘parameter_meta’ $ws* ‘{‘ ($ws* $parameter_meta_kv $ws*)* ‘}’
$parameter_meta_kv = $identifier $ws* ‘=’ $ws* $string</p>
<p>This purely optional section contains key/value pairs where the keys are names of parameters and the values are string descriptions for those parameters.</p>
<blockquote>
<div>Additional requirement: Any key in this section MUST correspond to a parameter in the command line</div></blockquote>
<p>Metadata Section</p>
<p>🐖 Cromwell supported ✅</p>
<p>$meta = ‘meta’ $ws* ‘{‘ ($ws* $meta_kv $ws*)* ‘}’
$meta_kv = $identifier $ws* ‘=’ $ws* $string</p>
<p>This purely optional section contains key/value pairs for any additional meta data that should be stored with the task. For example, perhaps author or contact email.
Examples
Example 1: Simplest Task</p>
<dl class="docutils">
<dt>task hello_world {</dt>
<dd>command {echo hello world}</dd>
</dl>
<p>}</p>
<p>Example 2: Inputs/Outputs</p>
<dl class="docutils">
<dt>task one_and_one {</dt>
<dd><p class="first">String pattern
File infile</p>
<dl class="docutils">
<dt>command {</dt>
<dd>grep ${pattern} ${infile}</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>File filtered = stdout()</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Example 3: Runtime/Metadata</p>
<dl class="docutils">
<dt>task runtime_meta {</dt>
<dd><p class="first">String memory_mb
String sample_id
String param
String sample_id</p>
<dl class="docutils">
<dt>command {</dt>
<dd>java -Xmx${memory_mb}M -jar task.jar -id ${sample_id} -param ${param} -out ${sample_id}.out</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>File results = “${sample_id}.out”</div></blockquote>
<p>}
runtime {</p>
<blockquote>
<div>docker: “broadinstitute/baseimg”</div></blockquote>
<p>}
parameter_meta {</p>
<blockquote>
<div>memory_mb: “Amount of memory to allocate to the JVM”
param: “Some arbitrary parameter”
sample_id: “The ID of the sample in format foo_bar_baz”</div></blockquote>
<p>}
meta {</p>
<blockquote>
<div>author: “Joe Somebody”
email: “<a class="reference external" href="mailto:joe&#37;&#52;&#48;company&#46;org">joe<span>&#64;</span>company<span>&#46;</span>org</a>”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Example 4: BWA mem</p>
<dl class="docutils">
<dt>task bwa_mem_tool {</dt>
<dd><p class="first">Int threads
Int min_seed_length
Int min_std_max_min
File reference
File reads</p>
<dl class="docutils">
<dt>command {</dt>
<dd><dl class="first last docutils">
<dt>bwa mem -t ${threads} </dt>
<dd>-k ${min_seed_length} -I ${sep=’,’ min_std_max_min+} ${reference} ${sep=’ ‘ reads+} &gt; output.sam</dd>
</dl>
</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>File sam = “output.sam”</div></blockquote>
<p>}
runtime {</p>
<blockquote>
<div>docker: “broadinstitute/baseimg”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Notable pieces in this example is ${sep=’,’ min_std_max_min+} which specifies that min_std_max_min can be one or more integers (the + after the variable name indicates that it can be one or more). If an Array[Int] is passed into this parameter, then it’s flattened by combining the elements with the separator character (sep=’,’).</p>
<p>This task also defines that it exports one file, called ‘sam’, which is the stdout of the execution of bwa mem.</p>
<p>The ‘docker’ portion of this task definition specifies which that this task must only be run on the Docker image specified.
Example 5: Word Count</p>
<dl class="docutils">
<dt>task wc2_tool {</dt>
<dd><p class="first">File file1
command {</p>
<blockquote>
<div>wc ${file1}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Int count = read_int(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow count_lines4_wf {</dt>
<dd><p class="first">Array[File] files
scatter(f in files) {</p>
<blockquote>
<div><dl class="docutils">
<dt>call wc2_tool {</dt>
<dd>input: file1=f</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>wc2_tool.count</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>In this example, it’s all pretty boilerplate, declarative code, except for some language-y like features, like firstline(stdout) and append(list_of_count, wc2-tool.count). These both can be implemented fairly easily if we allow for custom function definitions. Parsing them is no problem. Implementation would be fairly simple and new functions would not be hard to add. Alternatively, this could be something like JavaScript or Python snippets that we run.
Example 6: tmap</p>
<p>This task should produce a command line like this:</p>
<p>tmap mapall stage1 map1 –min-seq-length 20 </p>
<blockquote>
<div>map2 –min-seq-length 20 </div></blockquote>
<dl class="docutils">
<dt>stage2 map1 –max-seq-length 20 –min-seq-length 10 –seed-length 16 </dt>
<dd>map2 –max-seed-hits -1 –max-seq-length 20 –min-seq-length 10</dd>
</dl>
<p>Task definition would look like this:</p>
<dl class="docutils">
<dt>task tmap_tool {</dt>
<dd><p class="first">Array[String] stages
File reads</p>
<dl class="docutils">
<dt>command {</dt>
<dd>tmap mapall ${sep=’ ‘ stages} &lt; ${reads} &gt; output.sam</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>File sam = “output.sam”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>For this particular case where the command line is itself a mini DSL, The best option at that point is to allow the user to type in the rest of the command line, which is what ${sep=’ ‘ stages+} is for. This allows the user to specify an array of strings as the value for stages and then it concatenates them together with a space character
Variable        Value
reads   /path/to/fastq
stages  [“stage1 map1 –min-seq-length 20 map2 –min-seq-length 20”, “stage2 map1 –max-seq-length 20 –min-seq-length 10 –seed-length 16 map2 –max-seed-hits -1 –max-seq-length 20 –min-seq-length 10”]
Workflow Definition</p>
<p>🐖 Cromwell supported ✅</p>
<p>$workflow = ‘workflow’ $ws* ‘{‘ $ws* $workflow_element* $ws* ‘}’
$workflow_element = $call | $loop | $conditional | $declaration | $scatter | $parameter_meta | $meta</p>
<p>A workflow is defined as the keyword workflow and the body being in curly braces.</p>
<p>An example of a workflow that runs one task (not defined here) would be:</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Array[File] files
Int threshold
Map[String, String] my_map</p>
<dl class="docutils">
<dt>call analysis_job {</dt>
<dd>input: search_paths=files, threshold=threshold, gender_lookup=my_map</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Call Statement</p>
<p>🐖 Cromwell supported ✅</p>
<p>$call = ‘call’ $ws* $namespaced_identifier $ws+ (‘as’ $identifier)? $ws* $call_body?
$call_body = ‘{‘ $ws* $inputs? $ws* ‘}’
$inputs = ‘input’ $ws* ‘:’ $ws* $variable_mappings
$variable_mappings = $variable_mapping_kv (‘,’ $variable_mapping_kv)*
$variable_mapping_kv = $identifier $ws* ‘=’ $ws* $expression</p>
<p>A workflow may call other tasks/workflows via the call keyword. The $namespaced_identifier is the reference to which task to run. Most commonly, it’s simply the name of a task (see examples below), but it can also use . as a namespace resolver.</p>
<p>See the section on Fully Qualified Names &amp; Namespaced Identifiers for details about how the $namespaced_identifier ought to be interpreted</p>
<p>All call statements must be uniquely identifiable. By default, the call’s unique identifier is the task name (e.g. call foo would be referenced by name foo). However, if one were to call foo twice in a workflow, each subsequent call statement will need to alias itself to a unique name using the as clause: call foo as bar.</p>
<p>A call statement may reference a workflow too (e.g. call other_workflow). In this case, the $inputs section specifies a subset of the workflow’s inputs and must specify fully qualified names.</p>
<p>import “lib.wdl” as lib
workflow wf {</p>
<blockquote>
<div><p>call my_task
call my_task as my_task_alias
call my_task as my_task_alias2 {</p>
<blockquote>
<div>input: threshold=2</div></blockquote>
<p>}
call lib.other_task</p>
</div></blockquote>
<p>}</p>
<p>The $call_body is optional and is meant to specify how to satisfy a subset of the the task or workflow’s input parameters as well as a way to map tasks outputs to variables defined in the visible scopes.</p>
<p>A $variable_mapping in the $inputs section maps parameters in the task to expressions. These expressions usually reference outputs of other tasks, but they can be arbitrary expressions.</p>
<p>As an example, here is a workflow in which the second task requires an output from the first task:</p>
<dl class="docutils">
<dt>task task1 {</dt>
<dd><dl class="first docutils">
<dt>command {</dt>
<dd>python do_stuff.py</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>File results = stdout()</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}
task task2 {</p>
<blockquote>
<div><p>File foobar
command {</p>
<blockquote>
<div>python do_stuff2.py ${foobar}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>File results = stdout()</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
workflow wf {</p>
<blockquote>
<div><p>call task1
call task2 {</p>
<blockquote>
<div>input: foobar=task1.results</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>Sub Workflows</p>
<p>🐖 Cromwell supported ✅</p>
<p>Workflows can also be called inside of workflows.</p>
<p>main.wdl</p>
<p>import “sub_wdl.wdl” as sub</p>
<p>workflow main_workflow {</p>
<blockquote>
<div><p>call sub.wf_hello { input: wf_hello_input = “sub world” }</p>
<dl class="docutils">
<dt>output {</dt>
<dd>String main_output = wf_hello.salutation</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>sub_wdl.wdl</p>
<dl class="docutils">
<dt>task hello {</dt>
<dd><p class="first">String addressee
command {</p>
<blockquote>
<div>echo “Hello ${addressee}!”</div></blockquote>
<p>}
runtime {</p>
<blockquote>
<div>docker: “ubuntu:latest”</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>String salutation = read_string(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf_hello {</dt>
<dd><p class="first">String wf_hello_input</p>
<p>call hello {input: addressee = wf_hello_input }</p>
<dl class="docutils">
<dt>output {</dt>
<dd>String salutation = hello.salutation</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Note that because a wdl file can only contain 1 workflow, sub workflows can only be used through imports. Otherwise, calling a workflow or a task is equivalent syntactically. Inputs are specified and outputs retrieved the same way as they are for task calls.
Scatter</p>
<p>🐖 Cromwell supported ✅</p>
<p>$scatter = ‘scatter’ $ws* ‘(‘ $ws* $scatter_iteration_statment $ws*  ‘)’ $ws* $scatter_body
$scatter_iteration_statment = $identifier $ws* ‘in’ $ws* $expression
$scatter_body = ‘{‘ $ws* $workflow_element* $ws* ‘}’</p>
<p>A “scatter” clause defines that everything in the body ($scatter_body) can be run in parallel. The clause in parentheses ($scatter_iteration_statement) declares which collection to scatter over and what to call each element.</p>
<p>The $scatter_iteration_statement has two parts: the “item” and the “collection”. For example, scatter(x in y) would define x as the item, and y as the collection. The item is always an identifier, while the collection is an expression that MUST evaluate to an Array type. The item will represent each item in that expression. For example, if y evaluated to an Array[String] then x would be a String.</p>
<p>The $scatter_body defines a set of scopes that will execute in the context of this scatter block.</p>
<p>For example, if $expression is an array of integers of size 3, then the body of the scatter clause can be executed 3-times in parallel. $identifier would refer to each integer in the array.</p>
<dl class="docutils">
<dt>scatter(i in integers) {</dt>
<dd>call task1{input: num=i}
call task2{input: num=task1.output}</dd>
</dl>
<p>}</p>
<p>In this example, task2 depends on task1. Variable i has an implicit index attribute to make sure we can access the right output from task1. Since both task1 and task2 run N times where N is the length of the array integers, any scalar outputs of these tasks is now an array.
Loops</p>
<p>🐖 Coming soon in Cromwell</p>
<p>$loop = ‘while’ ‘(‘ $expression ‘)’ ‘{‘ $workflow_element* ‘}’</p>
<p>Loops are distinct from scatter clauses because the body of a while loop needs to be executed to completion before another iteration is considered for iteration. The $expression condition is evaluated only when the iteration count is zero or if all $workflow_elements in the body have completed successfully for the current iteration.
Conditionals</p>
<p>🐖 Available in Cromwell version 24 and higher</p>
<p>$conditional = ‘if’ ‘(‘ $expression ‘)’ ‘{‘ $workflow_element* ‘}’</p>
<p>Conditionals only execute the body if the expression evaluates to true.</p>
<blockquote>
<div>When a call’s output is referenced outside the same containing if it will need to be handled as an optional type. E.g.</div></blockquote>
<dl class="docutils">
<dt>workflow foo {</dt>
<dd><p class="first"># Call ‘x’, producing a Boolean output:
call x
Boolean x_out = x.out</p>
<p># Call ‘y’, producing an Int output, in a conditional block:
if (x_out) {</p>
<blockquote>
<div>call y
Int y_out = y.out</div></blockquote>
<p>}</p>
<p># Outside the if block, we have to handle this output as optional:
Int? y_out_maybe = y.out</p>
<p class="last"># Call ‘z’ which takes an optional Int input:
call z { input: optional_int = y_out_maybe }</p>
</dd>
</dl>
<p>}</p>
<blockquote>
<div>Optional types can be coalesced by using the select_all and select_first array functions:</div></blockquote>
<dl class="docutils">
<dt>workflow foo {</dt>
<dd><p class="first">Array[Int] scatter_range = [1, 2, 3, 4, 5]
scatter (i in scatter_range) {</p>
<blockquote>
<div><p>call x { input: i = i }
if (x.validOutput) {</p>
<blockquote>
<div>Int x_out = x.out</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p># Because it was declared inside the scatter and the if-block, the type of x_out is different here:
Array[Int?] x_out_maybes = x_out</p>
<p># We can select only the valid elements with select_all:
Array[Int] x_out_valids = select_all(x_out_maybes)</p>
<p class="last"># Or we can select the first valid element:
Int x_out_first = select_first(x_out_maybes)</p>
</dd>
</dl>
<p>}</p>
<p>Parameter Metadata</p>
<p>🐖 Cromwell supported ✅</p>
<p>$wf_parameter_meta = ‘parameter_meta’ $ws* ‘{‘ ($ws* $wf_parameter_meta_kv $ws*)* ‘}’
$wf_parameter_meta_kv = $identifier $ws* ‘=’ $ws* $string</p>
<p>This purely optional section contains key/value pairs where the keys are names of parameters and the values are string descriptions for those parameters.</p>
<blockquote>
<div>Additional requirement: Any key in this section MUST correspond to a worflow input</div></blockquote>
<p>As an example:</p>
<blockquote>
<div><dl class="docutils">
<dt>parameter_meta {</dt>
<dd>memory_mb: “Amount of memory to allocate to the JVM”
param: “Some arbitrary parameter”
sample_id: “The ID of the sample in format foo_bar_baz”</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>Metadata</p>
<p>🐖 Cromwell supported ✅</p>
<p>$wf_meta = ‘meta’ $ws* ‘{‘ ($ws* $wf_meta_kv $ws*)* ‘}’
$wf_meta_kv = $identifier $ws* ‘=’ $ws* $string</p>
<p>This purely optional section contains key/value pairs for any additional meta data that should be stored with the workflow. For example, perhaps author or contact email.</p>
<p>As an example:</p>
<blockquote>
<div><dl class="docutils">
<dt>meta {</dt>
<dd>author: “Joe Somebody”
email: “<a class="reference external" href="mailto:joe&#37;&#52;&#48;company&#46;org">joe<span>&#64;</span>company<span>&#46;</span>org</a>”</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>Outputs</p>
<p>🐖 Cromwell supported ✅</p>
<p>Each workflow definition can specify an optional output section. This section lists outputs from individual calls that you also want to expose as outputs to the workflow itself. If the output {…} section is omitted, then the workflow includes all outputs from all calls in its final output. Workflow outputs follow the same syntax rules as task outputs. They can reference call outputs, workflow inputs and previous workflow outputs. e.g:</p>
<dl class="docutils">
<dt>task t {</dt>
<dd><dl class="first docutils">
<dt>command {</dt>
<dd># do something</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>String out = “out”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow w {</dt>
<dd><p class="first">String w_input = “some input”</p>
<p>call t
call t as u</p>
<dl class="docutils">
<dt>output {</dt>
<dd>String t_out = t.out
String u_out = u.out
String input_as_output = w_input
String previous_output = u_out</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Note that they can’t reference call inputs. However this can be achieved by declaring the desired call input as an output. Expressions are allowed.</p>
<p>When declaring a workflow output that points to a call inside a scatter, the aggregated call is used. e.g:</p>
<dl class="docutils">
<dt>task t {</dt>
<dd><dl class="first docutils">
<dt>command {</dt>
<dd># do something</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>String out = “out”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow w {</dt>
<dd><p class="first">Array[Int] arr = [1, 2]</p>
<dl class="docutils">
<dt>scatter(i in arr) {</dt>
<dd>call t</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Array[String] t_out = t.out</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>t_out has an Array[String] result type, because call t is inside a scatter.</p>
<p>THE FOLLOWING SYNTAX IS DEPRECATED BUT IS STILL SUPPORTED TO MAINTAIN BACKWARD COMPATIBILITY</p>
<p>$workflow_output = ‘output’ ‘{‘ ($workflow_output_fqn ($workflow_output_fqn)* ‘}’
$workflow_output_fqn = $fully_qualified_name ‘.*’?</p>
<p>Replacing call output names with a * acts as a match-all wildcard.</p>
<p>The output names in this section must be qualified with the call which created them, as in the example below.</p>
<dl class="docutils">
<dt>task task1 {</dt>
<dd>command { ./script }
output { File results = stdout() }</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>task task2 {</dt>
<dd><p class="first">command { ./script2 }
output {</p>
<blockquote>
<div>File results = stdout()
String value = read_string(“some_file”)</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">call task1
call task2 as altname
output {</p>
<blockquote>
<div>task1.*
altname.value</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>In this example, the fully-qualified names that would be exposed as workflow outputs would be wf.task1.results, wf.altname.value.
Namespaces</p>
<p>🐖 Cromwell supported ✅</p>
<p>Import statements can be used to pull in tasks/workflows from other locations as well as to create namespaces. In the simplest case, an import statement adds the tasks/workflows that are imported into the specified namespace. For example:</p>
<p>tasks.wdl</p>
<dl class="docutils">
<dt>task x {</dt>
<dd>command { python script.py }</dd>
</dl>
<p>}
task y {</p>
<blockquote>
<div>command { python script2.py }</div></blockquote>
<p>}</p>
<p>workflow.wdl</p>
<p>import “tasks.wdl” as pyTasks</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd>call pyTasks.x
call pyTasks.y</dd>
</dl>
<p>}</p>
<p>Tasks x and y are inside the namespace pyTasks, which is different from the wf namespace belonging to the primary workflow. However, if no namespace is specified for tasks.wdl:</p>
<p>workflow.wdl</p>
<p>import “tasks.wdl”</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd>call tasks.x
call tasks.y</dd>
</dl>
<p>}</p>
<p>Now everything inside of tasks.wdl must be accessed through the default namespace tasks.</p>
<p>Each namespace may contain namespaces, tasks, and at most one workflow. The names of the contained namespaces, tasks, and workflow need to be unique within that namespace. For example, one cannot import two workflows while they have the same namespace identifier. Additionally, a workflow and a namespace both named foo cannot exist inside a common namespace. Similarly there cannot be a task foo in a workflow also named foo. However, you can import two workflows with different namespace identifiers that have identically named tasks. For example, you can import namespaces foo and bar, both of which contain a task baz, and you can call foo.baz and bar.baz from the same primary workflow.
Scope</p>
<p>🐖 Cromwell supported ✅</p>
<p>Scopes are defined as:</p>
<blockquote>
<div>workflow {…} blocks
call blocks
while(expr) {…} blocks
if(expr) {…} blocks
scatter(x in y) {…} blocks</div></blockquote>
<p>Inside of any scope, variables may be declared. The variables declared in that scope are visible to any sub-scope, recursively. For example:</p>
<dl class="docutils">
<dt>task my_task {</dt>
<dd><p class="first">Int x
File f
command {</p>
<blockquote>
<div>my_cmd –integer=${var} ${f}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Array[File] files
Int x = 2
scatter(file in files) {</p>
<blockquote>
<div><p>Int x = 3
call my_task {</p>
<blockquote>
<div>Int x = 4
input: var=x, f=file</div></blockquote>
<p>}</p>
</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>my_task will use x=4 to set the value for var in its command line. However, my_task also needs a value for x which is defined at the task level. Since my_task has two inputs (x and var), and only one of those is set in the call my_task declaration, the value for my_task.x still needs to be provided by the user when the workflow is run.
Optional Parameters &amp; Type Constraints</p>
<p>🐖 Cromwell supported ✅</p>
<p>Types can be optionally suffixed with a ? or + in certain cases.</p>
<blockquote>
<div>? means that the parameter is optional. A user does not need to specify a value for the parameter in order to satisfy all the inputs to the workflow.
+ applies only to Array types and it represents a constraint that the Array value must containe one-or-more elements.</div></blockquote>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[File]  a
Array[File]+ b
Array[File]? c
#File+ d &lt;– can’t do this, + only applies to Arrays</p>
<dl class="docutils">
<dt>command {</dt>
<dd>/bin/mycmd ${sep=” ” a}
/bin/mycmd ${sep=”,” b}
/bin/mycmd ${write_lines(c)}</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd>call test</dd>
</dl>
<p>}</p>
<p>If you provided these values for inputs:
var     value
wf.test.a       [“1”, “2”, “3”]
wf.test.b       []</p>
<p>The workflow engine should reject this because wf.test.b is required to have at least one element. If we change it to:
var     value
wf.test.a       [“1”, “2”, “3”]
wf.test.b       [“x”]</p>
<p>This would be valid input because wf.test.c is not required. Given these values, the command would be instantiated as:</p>
<p>/bin/mycmd 1 2 3
/bin/mycmd x
/bin/mycmd</p>
<p>If our inputs were:
var     value
wf.test.a       [“1”, “2”, “3”]
wf.test.b       [“x”,”y”]
wf.test.c       [“a”,”b”,”c”,”d”]</p>
<p>Then the command would be instantiated as:</p>
<p>/bin/mycmd 1 2 3
/bin/mycmd x,y
/bin/mycmd /path/to/c.txt</p>
<p>Prepending a String to an Optional Parameter</p>
<p>🐖 Cromwell supported ✅</p>
<p>Sometimes, optional parameters need a string prefix. Consider this task:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">String? val
command {</p>
<blockquote>
<div>python script.py –val=${val}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Since val is optional, this command line can be instantiated in two ways:</p>
<p>python script.py –val=foobar</p>
<p>Or</p>
<p>python script.py –val=</p>
<p>The latter case is very likely an error case, and this –val= part should be left off if a value for val is omitted. To solve this problem, modify the expression inside the template tag as follows:</p>
<p>python script.py ${“–val=” + val}</p>
<p>Scatter / Gather</p>
<p>🐖 Cromwell supported ✅</p>
<p>The scatter block is meant to parallelize a series of identical tasks but give them slightly different inputs. The simplest example is:</p>
<dl class="docutils">
<dt>task inc {</dt>
<dd><p class="first">Int i</p>
<p>command &lt;&lt;&lt;
python -c “print(${i} + 1)”
&gt;&gt;&gt;</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Int incremented = read_int(stdout())</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Array[Int] integers = [1,2,3,4,5]
scatter(i in integers) {</p>
<blockquote>
<div>call inc{input: i=i}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Running this workflow (which needs no inputs), would yield a value of [2,3,4,5,6] for wf.inc. While task inc itself returns an Int, when it is called inside a scatter block, that type becomes an Array[Int].</p>
<p>Any task that’s downstream from the call to inc and outside the scatter block must accept an Array[Int]:</p>
<dl class="docutils">
<dt>task inc {</dt>
<dd><p class="first">Int i</p>
<p>command &lt;&lt;&lt;
python -c “print(${i} + 1)”
&gt;&gt;&gt;</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Int incremented = read_int(stdout())</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>task sum {</dt>
<dd><p class="first">Array[Int] ints</p>
<p>command &lt;&lt;&lt;
python -c “print(${sep=”+” ints})”
&gt;&gt;&gt;</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Int sum = read_int(stdout())</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Array[Int] integers = [1,2,3,4,5]
scatter (i in integers) {</p>
<blockquote>
<div>call inc {input: i=i}</div></blockquote>
<p class="last">}
call sum {input: ints = inc.increment}</p>
</dd>
</dl>
<p>}</p>
<p>This workflow will output a value of 20 for wf.sum.sum. This works because call inc will output an Array[Int] because it is in the scatter block.</p>
<p>However, from inside the scope of the scatter block, the output of call inc is still an Int. So the following is valid:</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Array[Int] integers = [1,2,3,4,5]
scatter(i in integers) {</p>
<blockquote>
<div>call inc {input: i=i}
call inc as inc2 {input: i=inc.incremented}</div></blockquote>
<p class="last">}
call sum {input: ints = inc2.increment}</p>
</dd>
</dl>
<p>}</p>
<p>In this example, inc and inc2 are being called in serial where the output of one is fed to another. inc2 would output the array [3,4,5,6,7]
Variable Resolution</p>
<p>🐖 Cromwell supported ✅</p>
<p>Inside of expressions, variables are resolved differently depending on if the expression is in a task declaration or a workflow declaration
Task-Level Resolution</p>
<p>🐖 Cromwell supported ✅</p>
<p>Inside a task, resolution is trivial: The variable referenced MUST be a declaration of the task. For example:</p>
<dl class="docutils">
<dt>task my_task {</dt>
<dd><p class="first">Array[String] strings
command {</p>
<blockquote>
<div>python analyze.py –strings-file=${write_lines(strings)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Inside of this task, there exists only one expression: write_lines(strings). In here, when the expression evaluator tries to resolve strings, which must be a declaration of the task (in this case it is).
Workflow-Level Resolution</p>
<p>🐖 Cromwell supported ✅</p>
<p>In a workflow, resolution works by traversing the scope heirarchy starting from expression that references the variable.</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">String s = “wf_s”
String t = “t”
call my_task {</p>
<blockquote>
<div>String s = “my_task_s”
input: in0 = s+”-suffix”, in1 = t+”-suffix”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>In this example, there are two expressions: s+”-suffix” and t+”-suffix”. s is resolved as “my_task_s” and t is resolved as “t”.
Computing Inputs</p>
<p>🐖 Cromwell supported ✅</p>
<p>Both tasks and workflows have a typed inputs that must be satisfied in order to run. The following sections describe how to compute inputs for task and workflow declarations
Task Inputs</p>
<p>🐖 Cromwell supported ✅</p>
<p>Tasks define all their inputs as declarations at the top of the task definition.</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">String s
Int i
Float f</p>
<dl class="docutils">
<dt>command {</dt>
<dd>./script.sh -i ${i} -f ${f}</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>In this example, s, i, and f are inputs to this task. Even though the command line does not reference ${s}. Implementations of WDL engines may display a warning or report an error in this case, since s isn’t used.
Workflow Inputs</p>
<p>🐖 Cromwell supported ✅</p>
<p>Workflows have declarations, like tasks, but a workflow must also account for all calls to sub-tasks when determining inputs.</p>
<p>Workflows also return their inputs as fully qualified names. Tasks only return the names of the variables as inputs (as they’re guaranteed to be unique within a task). However, since workflows can call the same task twice, names might collide. The general algorithm for computing inputs going something like this:</p>
<blockquote>
<div>Take all inputs to all call statements in the workflow
Subtract out all inputs that are satisfied through the input: section
Add in all declarations which don’t have a static value defined</div></blockquote>
<p>Consider the following workflow:</p>
<dl class="docutils">
<dt>task t1 {</dt>
<dd><p class="first">String s
Int x</p>
<dl class="docutils">
<dt>command {</dt>
<dd>./script –action=${s} -x${x}</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>Int count = read_int(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>task t2 {</dt>
<dd><p class="first">String s
Int t
Int x</p>
<dl class="docutils">
<dt>command {</dt>
<dd>./script2 –action=${s} -x${x} –other=${t}</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>Int count = read_int(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>task t3 {</dt>
<dd><p class="first">Int y
File ref_file # Do nothing with this</p>
<dl class="docutils">
<dt>command {</dt>
<dd>python -c “print(${y} + 1)”</dd>
</dl>
<p>}
output {</p>
<blockquote>
<div>Int incr = read_int(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>workflow wf {</dt>
<dd><p class="first">Int int_val
Int int_val2 = 10
Array[Int] my_ints
File ref_file</p>
<dl class="docutils">
<dt>call t1 {</dt>
<dd>input: x=int_val</dd>
</dl>
<p>}
call t2 {</p>
<blockquote>
<div>input: x=int_val, t=t1.count</div></blockquote>
<p>}
scatter(i in my_ints) {</p>
<blockquote>
<div><dl class="docutils">
<dt>call t3 {</dt>
<dd>input: y=i, ref=ref_file</dd>
</dl>
<p>}</p>
</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>The inputs to wf would be:</p>
<blockquote>
<div>wf.t1.s as a String
wf.t2.s as a String
wf.int_val as an Int
wf.my_ints as an Array[Int]
wf.ref_file as a File</div></blockquote>
<p>Specifying Workflow Inputs in JSON</p>
<p>🐖 Cromwell supported ✅</p>
<p>Once workflow inputs are computed (see previous section), the value for each of the fully-qualified names needs to be specified per invocation of the workflow. Workflow inputs are specified in JSON or YAML format. In JSON, the inputs to the workflow in the previous section can be:</p>
<dl class="docutils">
<dt>{</dt>
<dd>“wf.t1.s”: “some_string”,
“wf.t2.s”: “some_string”,
“wf.int_val”: 3,
“wf.my_ints”: [5,6,7,8],
“wf.ref_file”: “/path/to/file.txt”</dd>
</dl>
<p>}</p>
<p>It’s important to note that the type in JSON must be coercable to the WDL type. For example wf.int_val expects an integer, but if we specified it in JSON as “wf.int_val”: “3”, this coercion from string to integer is not valid and would result in a type error. See the section on Type Coercion for more details.
Type Coercion</p>
<p>🐖 Cromwell supported ✅</p>
<p>WDL values can be created from either JSON values or from native language values. The below table references String-like, Integer-like, etc to refer to values in a particular programming language. For example, “String-like” could mean a java.io.String in the Java context or a str in Python. An “Array-like” could refer to a Seq in Scala or a list in Python.
WDL Type        Can Accept      Notes / Constraints
String  JSON String</p>
<blockquote>
<div>String-like
String  Identity coercion
File</div></blockquote>
<dl class="docutils">
<dt>File    JSON String     Interpreted as a file path</dt>
<dd>String-like     Interpreted as file path
String  Interpreted as file path
File    Identity Coercion</dd>
<dt>Int     JSON Number     Use floor of the value for non-integers</dt>
<dd>Integer-like
Int     Identity coercion</dd>
<dt>Float   JSON Number</dt>
<dd>Float-like
Float   Identity coercion</dd>
<dt>Boolean         JSON Boolean</dt>
<dd>Boolean-like
Boolean         Identity coercion</dd>
<dt>Array[T]        JSON Array      Elements must be coercable to T</dt>
<dd>Array-like      Elements must be coercable to T</dd>
<dt>Map[K, V]       JSON Object     keys and values must be coercable to K and V, respectively</dt>
<dd>Map-like        keys and values must be coercable to K and V, respectively</dd>
</dl>
<p>Standard Library
File stdout()</p>
<p>🐖 Cromwell supported ✅</p>
<p>Returns a File reference to the stdout that this task generated.
File stderr()</p>
<p>🐖 Cromwell supported ✅</p>
<p>Returns a File reference to the stderr that this task generated.
Array[String] read_lines(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a file-like object (String, File) as a parameter, this will read each line as a string and return an Array[String] representation of the lines in the file.</p>
<p>The order of the lines in the returned Array[String] must be the order in which the lines appear in the file-like object.</p>
<p>This task would grep through a file and return all strings that matched the pattern:</p>
<dl class="docutils">
<dt>task do_stuff {</dt>
<dd><p class="first">String pattern
File file
command {</p>
<blockquote>
<div>grep ‘${pattern}’ ${file}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Array[String] matches = read_lines(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Array[Array[String]] read_tsv(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>the read_tsv() function takes one parameter, which is a file-like object (String, File) and returns an Array[Array[String]] representing the table from the TSV file.</p>
<p>If the parameter is a String, this is assumed to be a local file path relative to the current working directory of the task.</p>
<p>For example, if I write a task that outputs a file to ./results/file_list.tsv, and my task is defined as:</p>
<dl class="docutils">
<dt>task do_stuff {</dt>
<dd><p class="first">File file
command {</p>
<blockquote>
<div>python do_stuff.py ${file}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Array[Array[String]] output_table = read_tsv(“./results/file_list.tsv”)</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Then when the task finishes, to fulfull the outputs_table variable, ./results/file_list.tsv must be a valid TSV file or an error will be reported.
Map[String, String] read_map(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a file-like object (String, File) as a parameter, this will read each line from a file and expect the line to have the format col1tcol2. In other words, the file-like object must be a two-column TSV file.</p>
<p>This task would grep through a file and return all strings that matched the pattern:</p>
<p>The following task would write a two-column TSV to standard out and that would be interpreted as a Map[String, String]:</p>
<dl class="docutils">
<dt>task do_stuff {</dt>
<dd><p class="first">String flags
File file
command {</p>
<blockquote>
<div>./script –flags=${flags} ${file}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Map[String, String] mapping = read_map(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Object read_object(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a file-like object that contains a 2-row and n-column TSV file, this function will turn that into an Object.</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd>python &lt;&lt;CODE
print(‘t’.join([“key_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
CODE</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Object my_obj = read_object(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>The command will output to stdout the following:</p>
<p>key_1tkey_2tkey_3
value_1tvalue_2tvalue_3</p>
<p>Which would be turned into an Object in WDL that would look like this:
Attribute       Value
key_1   “value_1”
key_2   “value_2”
key_3   “value_3”
Array[Object] read_objects(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a file-like object that contains a 2-row and n-column TSV file, this function will turn that into an Object.</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd>python &lt;&lt;CODE
print(‘t’.join([“key_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
CODE</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Array[Object] my_obj = read_objects(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>The command will output to stdout the following:</p>
<p>key_1tkey_2tkey_3
value_1tvalue_2tvalue_3
value_1tvalue_2tvalue_3
value_1tvalue_2tvalue_3</p>
<p>Which would be turned into an Array[Object] in WDL that would look like this:
Index   Attribute       Value
0       key_1   “value_1”</p>
<blockquote>
<div>key_2   “value_2”
key_3   “value_3”</div></blockquote>
<dl class="docutils">
<dt>1       key_1   “value_1”</dt>
<dd>key_2   “value_2”
key_3   “value_3”</dd>
<dt>2       key_1   “value_1”</dt>
<dd>key_2   “value_2”
key_3   “value_3”</dd>
</dl>
<p>mixed read_json(String|File)</p>
<p>🐖 Coming soon in Cromwell</p>
<p>the read_json() function takes one parameter, which is a file-like object (String, File) and returns a data type which matches the data structure in the JSON file. The mapping of JSON type to WDL type is:
JSON Type       WDL Type
object  Map[String, ?]
array   Array[?]
number  Int or Float
string  String
boolean         Boolean
null    ???</p>
<p>If the parameter is a String, this is assumed to be a local file path relative to the current working directory of the task.</p>
<p>For example, if I write a task that outputs a file to ./results/file_list.json, and my task is defined as:</p>
<dl class="docutils">
<dt>task do_stuff {</dt>
<dd><p class="first">File file
command {</p>
<blockquote>
<div>python do_stuff.py ${file}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Map[String, String] output_table = read_json(“./results/file_list.json”)</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Then when the task finishes, to fulfull the output_table variable, ./results/file_list.json must be a valid TSV file or an error will be reported.
Int read_int(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>The read_int() function takes a file path which is expected to contain 1 line with 1 integer on it. This function returns that integer.
String read_string(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>The read_string() function takes a file path which is expected to contain 1 line with 1 string on it. This function returns that string.</p>
<p>No trailing newline characters should be included
Float read_float(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>The read_float() function takes a file path which is expected to contain 1 line with 1 floating point number on it. This function returns that float.
Boolean read_boolean(String|File)</p>
<p>🐖 Cromwell supported ✅</p>
<p>The read_boolean() function takes a file path which is expected to contain 1 line with 1 Boolean value (either “true” or “false” on it). This function returns that Boolean value.
File write_lines(Array[String])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given something that’s compatible with Array[String], this writes each element to it’s own line on a file. with newline n characters as line separators.</p>
<dl class="docutils">
<dt>task example {</dt>
<dd><p class="first">Array[String] array = [“first”, “second”, “third”]
command {</p>
<blockquote>
<div>./script –file-list=${write_lines(array)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>If this task were run, the command might look like:</p>
<p>./script –file-list=/local/fs/tmp/array.txt</p>
<p>And /local/fs/tmp/array.txt would contain:</p>
<p>first
second
third</p>
<p>File write_tsv(Array[Array[String]])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given something that’s compatible with Array[Array[String]], this writes a TSV file of the data structure.</p>
<dl class="docutils">
<dt>task example {</dt>
<dd><p class="first">Array[String] array = [[“one”, “two”, “three”], [“un”, “deux”, “trois”]]
command {</p>
<blockquote>
<div>./script –tsv=${write_tsv(array)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>If this task were run, the command might look like:</p>
<p>./script –tsv=/local/fs/tmp/array.tsv</p>
<p>And /local/fs/tmp/array.tsv would contain:</p>
<p>onettwotthree
untdeuxttrois</p>
<p>File write_map(Map[String, String])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given something that’s compatible with Map[String, String], this writes a TSV file of the data structure.</p>
<dl class="docutils">
<dt>task example {</dt>
<dd><p class="first">Map[String, String] map = {“key1”: “value1”, “key2”: “value2”}
command {</p>
<blockquote>
<div>./script –map=${write_map(map)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>If this task were run, the command might look like:</p>
<p>./script –tsv=/local/fs/tmp/map.tsv</p>
<p>And /local/fs/tmp/map.tsv would contain:</p>
<p>key1tvalue1
key2tvalue2</p>
<p>File write_object(Object)</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given any Object, this will write out a 2-row, n-column TSV file with the object’s attributes and values.</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Object input
command &lt;&lt;&lt;</p>
<blockquote>
<div>/bin/do_work –obj=${write_object(input)}</div></blockquote>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  File results = stdout()</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>if input were to have the value:
Attribute       Value
key_1   “value_1”
key_2   “value_2”
key_3   “value_3”</p>
<p>The command would instantiate to:</p>
<p>/bin/do_work –obj=/path/to/input.tsv</p>
<p>Where /path/to/input.tsv would contain:</p>
<p>key_1tkey_2tkey_3
value_1tvalue_2tvalue_3</p>
<p>File write_objects(Array[Object])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given any Array[Object], this will write out a 2+ row, n-column TSV file with each object’s attributes and values.</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[Object] in
command &lt;&lt;&lt;</p>
<blockquote>
<div>/bin/do_work –obj=${write_objects(in)}</div></blockquote>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  File results = stdout()</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>if in were to have the value:
Index   Attribute       Value
0       key_1   “value_1”</p>
<blockquote>
<div>key_2   “value_2”
key_3   “value_3”</div></blockquote>
<dl class="docutils">
<dt>1       key_1   “value_4”</dt>
<dd>key_2   “value_5”
key_3   “value_6”</dd>
<dt>2       key_1   “value_7”</dt>
<dd>key_2   “value_8”
key_3   “value_9”</dd>
</dl>
<p>The command would instantiate to:</p>
<p>/bin/do_work –obj=/path/to/input.tsv</p>
<p>Where /path/to/input.tsv would contain:</p>
<p>key_1tkey_2tkey_3
value_1tvalue_2tvalue_3
value_4tvalue_5tvalue_6
value_7tvalue_8tvalue_9</p>
<p>File write_json(mixed)</p>
<p>🐖 Coming soon in Cromwell</p>
<p>Given something with any type, this writes the JSON equivalent to a file. See the table in the definition of read_json()</p>
<dl class="docutils">
<dt>task example {</dt>
<dd><p class="first">Map[String, String] map = {“key1”: “value1”, “key2”: “value2”}
command {</p>
<blockquote>
<div>./script –map=${write_json(map)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>If this task were run, the command might look like:</p>
<p>./script –tsv=/local/fs/tmp/map.json</p>
<p>And /local/fs/tmp/map.json would contain:</p>
<dl class="docutils">
<dt>{</dt>
<dd>“key1”: “value1”
“key2”: “value2”</dd>
</dl>
<p>}</p>
<p>Float size(File, [String])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a File and a String (optional), returns the size of the file in Bytes or in the unit specified by the second argument.</p>
<dl class="docutils">
<dt>task example {</dt>
<dd><p class="first">File input_file</p>
<dl class="docutils">
<dt>command {</dt>
<dd>echo “this file is 22 bytes” &gt; created_file</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>output {</dt>
<dd>Float input_file_size = size(input_file)
Float created_file_size = size(“created_file”) # 22.0
Float created_file_size_in_KB = size(“created_file”, “K”) # 0.022</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Supported units are KiloByte (“K”, “KB”), MegaByte (“M”, “MB”), GigaByte (“G”, “GB”), TeraByte (“T”, “TB”) as well as their binary version “Ki” (“KiB”), “Mi” (“MiB”), “Gi” (“GiB”), “Ti” (“TiB”). Default unit is Bytes (“B”).
String sub(String, String, String)</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given 3 String parameters input, pattern, replace, this function will replace any occurrence matching pattern in input by replace. pattern is expected to be a regular expression. Details of regex evaluation will depend on the execution engine running the WDL.</p>
<p>Example 1:</p>
<blockquote>
<div><p>String chocolike = “I like chocolate when it’s late”</p>
<p>String chocolove = sub(chocolike, “like”, “love”) # I love chocolate when it’s late
String chocoearly = sub(chocolike, “late”, “early”) # I like chocoearly when it’s early
String chocolate = sub(chocolike, “late$”, “early”) # I like chocolate when it’s early</p>
</div></blockquote>
<p>}</p>
<p>The sub function will also accept input and replace parameters that can be coerced to a String (e.g. File). This can be useful to swap the extension of a filename for example</p>
<p>Example 2:</p>
<blockquote>
<div><p>task example {
File input_file = “my_input_file.bam”
String output_file_name = sub(input_file, “.bam$”, “.index”) # my_input_file.index</p>
<dl class="docutils">
<dt>command {</dt>
<dd>echo “I want an index instead” &gt; ${output_file_name}</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>output {</dt>
<dd>File outputFile = output_file_name</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>Array[Int] range(Int)</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given an integer argument, the range function creates an array of integers of length equal to the given argument. For example range(3) provides the array: (0, 1, 2).
Array[Array[X]] transpose(Array[Array[X]])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a two dimensional array argument, the transpose function transposes the two dimensional array according to the standard matrix transpose rules. For example transpose( ((0, 1, 2), (3, 4, 5)) ) will return the rotated two-dimensional array: ((0, 3), (1, 4), (2, 5)).
Array[Pair[X,Y]] zip(Array[X], Array[Y])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given any two Object types, the zip function returns the dot product of those Object types in the form of a Pair object.</p>
<p>Pair[Int, String] p = (0, “z”)
Array[Int] xs = [ 1, 2, 3 ]
Array[String] ys = [ “a”, “b”, “c” ]
Array[String] zs = [ “d”, “e” ]</p>
<p>Array[Pair[Int, String]] zipped = zip(xs, ys)     # i.e.  zipped = [ (1, “a”), (2, “b”), (3, “c”) ]</p>
<p>Array[Pair[X,Y]] cross(Array[X], Array[Y])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given any two Object types, the cross function returns the cross product of those Object types in the form of a Pair object.</p>
<p>Pair[Int, String] p = (0, “z”)
Array[Int] xs = [ 1, 2, 3 ]
Array[String] ys = [ “a”, “b”, “c” ]
Array[String] zs = [ “d”, “e” ]</p>
<p>Array[Pair[Int, String]] crossed = cross(xs, zs) # i.e. crossed = [ (1, “d”), (1, “e”), (2, “d”), (2, “e”), (3, “d”), (3, “e”) ]</p>
<p>Integer length(Array[X])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given an Array, the length function returns the number of elements in the Array as an Integer.</p>
<p>Array[Int] xs = [ 1, 2, 3 ]
Array[String] ys = [ “a”, “b”, “c” ]
Array[String] zs = [ ]</p>
<p>Integer xlen = length(xs) # 3
Integer ylen = length(ys) # 3
Integer zlen = length(zs) # 0</p>
<p>Array[String] prefix(String, Array[X])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given a String and an Array[X] where X is a primitive type, the prefix function returns an array of strings comprised of each element of the input array prefixed by the specified prefix string. For example:</p>
<p>Array[String] env = [“key1=value1”, “key2=value2”, “key3=value3”]
Array[String] env_param = prefix(“-e “, env) # [“-e key1=value1”, “-e key2=value2”, “-e key3=value3”]</p>
<p>Array[Integer] env2 = [1, 2, 3]
Array[String] env2_param = prefix(“-f “, env2) # [“-f 1”, “-f 2”, “-f 3”]</p>
<p>X select_first(Array[X?])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given an array of optional values, select_first will select the first defined value and return it. Note that this is a runtime check and requires that at least one defined value will exist: if no defined value is found when select_first is evaluated, the workflow will fail.
Array[X] select_all(Array[X?])</p>
<p>🐖 Cromwell supported ✅</p>
<p>Given an array of optional values, select_all will select only those elements which are defined.
Boolean defined(X?)</p>
<p>🐖 Cromwell supported ✅</p>
<p>This function will return false if the argument is an unset optional value. It will return true in all other cases.
String basename(String)</p>
<p>🐖 Supported in Cromwell 27 ✅</p>
<blockquote>
<div>This function returns the basename of a file path passed to it: basename(“/path/to/file.txt”) returns “file.txt”.
Also supports an optional parameter, suffix to remove: basename(“/path/to/file.txt”, “.txt”) returns “file”.</div></blockquote>
<p>Int floor(Float), Int ceil(Float) and Int round(Float)</p>
<p>🐖 Supported in Cromwell 28 ✅</p>
<blockquote>
<div><dl class="docutils">
<dt>These functions convert a Float value into an Int by:</dt>
<dd>floor: Round down to the next lower integer
ceil: Round up to the next higher integer
round: Round to the nearest integer based on standard rounding rules</dd>
</dl>
</div></blockquote>
<p>Data Types &amp; Serialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Tasks and workflows are given values for their input parameters in order to run. The type of each of those input parameters are declarations on the task or workflow. Those input parameters can be any valid type:</p>
<p>Primitive Types:</p>
<blockquote>
<div>String
Int
Float
File
Boolean</div></blockquote>
<p>Compound Types:</p>
<blockquote>
<div>Array
Map
Object
Pair</div></blockquote>
<p>When a WDL workflow engine instantiates a command specified in the command section of a task, it must serialize all ${…} tags in the command into primitive types.</p>
<p>For example, if I’m writing a tool that operates on a list of FASTQ files, there are a variety of ways that this list can be passed to that task:</p>
<blockquote>
<div>A file containing one file path per line (e.g. Rscript analysis.R –files=fastq_list.txt)
A file containing a JSON list (e.g. Rscript analysis.R –files=fastq_list.json)
Enumerated on the command line (e.g. (Rscript analysis.R 1.fastq 2.fastq 3.fastq)</div></blockquote>
<p>Each of these methods has its merits and one method might be better for one tool while another method would be better for another tool.</p>
<p>On the other end, tasks need to be able to communicate data structures back to the workflow engine. For example, let’s say this same tool that takes a list of FASTQs wants to return back a Map[File, Int] representing the number of reads in each FASTQ. A tool might choose to output it as a two-column TSV or as a JSON object and WDL needs to know how to convert that to the proper data type.</p>
<p>WDL provides some standard library functions for converting compound types like Array into primitive types, like File.</p>
<p>When a task finishes, the output section defines how to convert the files and stdout/stderr into WDL types. For example,</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[File] files
command {</p>
<blockquote>
<div>Rscript analysis.R –files=${sep=’,’ files}</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Array[String] strs = read_lines(stdout())</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Here, the expression read_lines(stdout()) says “take the output from stdout, break into lines, and return that result as an Array[String]”. See the definition of read_lines and stdout for more details.
Serialization of Task Inputs
Primitive Types</p>
<p>🐖 Cromwell supported ✅</p>
<p>Serializing primitive inputs into strings is intuitively easy because the value is just turned into a string and inserted into the command line.</p>
<p>Consider this example:</p>
<dl class="docutils">
<dt>task output_example {</dt>
<dd><p class="first">String s
Int i
Float f</p>
<dl class="docutils">
<dt>command {</dt>
<dd>python do_work.py ${s} ${i} ${f}</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>If I provide values for the declarations in the task as:
var     value
s       “str”
i       2
f       1.3</p>
<p>Then, the command would be instantiated as:</p>
<p>python do_work.py str 2 1.3</p>
<p>Compound Types</p>
<p>🐖 Cromwell supported ✅</p>
<p>Compound types, like Array and Map must be converted to a primitive type before it can be used in the command. There are many ways to turn a compound types into primitive types, as laid out in following sections
Array serialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Arrays can be serialized in two ways:</p>
<blockquote>
<div>Array Expansion: elements in the list are flattened to a string with a separator character.
File Creation: create a file with the elements of the array in it and passing that file as the parameter on the command line.</div></blockquote>
<p>Array serialization by expansion</p>
<p>🐖 Cromwell supported ✅</p>
<p>The array flattening approach can be done if a parameter is specified as ${sep=’ ‘ my_param}. my_param must be declared as an Array of primitive types. When the value of my_param is specified, then the values are joined together with the separator character (a space in this case). For example:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[File] bams
command {</p>
<blockquote>
<div>python script.py –bams=${sep=’,’ bams}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>If passed an array for the value of bams:
Element
/path/to/1.bam
/path/to/2.bam
/path/to/3.bam</p>
<p>Would produce the command python script.py –bams=/path/to/1.bam,/path/to/2.bam,/path/to/1.bam
Array serialization using write_lines()</p>
<p>🐖 Cromwell supported ✅</p>
<p>An array may be turned into a file with each element in the array occupying a line in the file.</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[File] bams
command {</p>
<blockquote>
<div>sh script.sh ${write_lines(bams)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if bams is given this array:
Element
/path/to/1.bam
/path/to/2.bam
/path/to/3.bam</p>
<p>Then, the resulting command line could look like:</p>
<p>sh script.sh /jobs/564758/bams</p>
<p>Where /jobs/564758/bams would contain:</p>
<p>/path/to/1.bam
/path/to/2.bam
/path/to/3.bam</p>
<p>Array serialization using write_json()</p>
<p>🐖 Coming soon in Cromwell</p>
<p>The array may be turned into a JSON document with the file path for the JSON file passed in as the parameter:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[File] bams
command {</p>
<blockquote>
<div>sh script.sh ${write_json(bams)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if bams is given this array:
Element
/path/to/1.bam
/path/to/2.bam
/path/to/3.bam</p>
<p>Then, the resulting command line could look like:</p>
<p>sh script.sh /jobs/564758/bams.json</p>
<p>Where /jobs/564758/bams.json would contain:</p>
<dl class="docutils">
<dt>[</dt>
<dd>“/path/to/1.bam”,
“/path/to/2.bam”,
“/path/to/3.bam”</dd>
</dl>
<p>]</p>
<p>Map serialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Map types cannot be serialized on the command line directly and must be serialized through a file
Map serialization using write_map()</p>
<p>🐖 Cromwell supported ✅</p>
<p>The map type can be serialized as a two-column TSV file and the parameter on the command line is given the path to that file, using the write_map() function:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Map[String, Float] sample_quality_scores
command {</p>
<blockquote>
<div>sh script.sh ${write_map(sample_quality_scores)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if sample_quality_scores is given this Map[String, Float] as:
Key     Value
sample1         98
sample2         95
sample3         75</p>
<p>Then, the resulting command line could look like:</p>
<p>sh script.sh /jobs/564757/sample_quality_scores.tsv</p>
<p>Where /jobs/564757/sample_quality_scores.tsv would contain:</p>
<p>sample1t98
sample2t95
sample3t75</p>
<p>Map serialization using write_json()</p>
<p>🐖 Coming soon in Cromwell</p>
<p>The map type can also be serialized as a JSON file and the parameter on the command line is given the path to that file, using the write_json() function:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Map[String, Float] sample_quality_scores
command {</p>
<blockquote>
<div>sh script.sh ${write_json(sample_quality_scores)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if sample_quality_scores is given this map:
Key     Value
sample1         98
sample2         95
sample3         75</p>
<p>Then, the resulting command line could look like:</p>
<p>sh script.sh /jobs/564757/sample_quality_scores.json</p>
<p>Where /jobs/564757/sample_quality_scores.json would contain:</p>
<dl class="docutils">
<dt>{</dt>
<dd>“sample1”: 98,
“sample2”: 95,
“sample3”: 75</dd>
</dl>
<p>}</p>
<p>Object serialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>An object is a more general case of a map where the keys are strings and the values are of arbitrary types and treated as strings. Objects can be serialized with either write_object() or write_json() functions:
Object serialization using write_object()</p>
<p>🐖 Cromwell supported ✅</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Object sample
command {</p>
<blockquote>
<div>perl script.pl ${write_object(sample)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if sample is provided as:
Attribute       Value
attr1   value1
attr2   value2
attr3   value3
attr4   value4</p>
<p>Then, the resulting command line could look like:</p>
<p>perl script.pl /jobs/564759/sample.tsv</p>
<p>Where /jobs/564759/sample.tsv would contain:</p>
<p>attr1tattr2tattr3tattr4
value1tvalue2tvalue3tvalue4</p>
<p>Object serialization using write_json()</p>
<p>🐖 Coming soon in Cromwell</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Object sample
command {</p>
<blockquote>
<div>perl script.pl ${write_json(sample)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if sample is provided as:
Attribute       Value
attr1   value1
attr2   value2
attr3   value3
attr4   value4</p>
<p>Then, the resulting command line could look like:</p>
<p>perl script.pl /jobs/564759/sample.json</p>
<p>Where /jobs/564759/sample.json would contain:</p>
<dl class="docutils">
<dt>{</dt>
<dd>“attr1”: “value1”,
“attr2”: “value2”,
“attr3”: “value3”,
“attr4”: “value4”,</dd>
</dl>
<p>}</p>
<p>Array[Object] serialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Array[Object] must guarantee that all objects in the array have the same set of attributes. These can be serialized with either write_objects() or write_json() functions, as described in following sections.
Array[Object] serialization using write_objects()</p>
<p>🐖 Cromwell supported ✅</p>
<p>an Array[Object] can be serialized using write_objects() into a TSV file:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[Object] sample
command {</p>
<blockquote>
<div>perl script.pl ${write_objects(sample)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if sample is provided as:
Index   Attribute       Value
0       attr1   value1</p>
<blockquote>
<div>attr2   value2
attr3   value3
attr4   value4</div></blockquote>
<dl class="docutils">
<dt>1       attr1   value5</dt>
<dd>attr2   value6
attr3   value7
attr4   value8</dd>
</dl>
<p>Then, the resulting command line could look like:</p>
<p>perl script.pl /jobs/564759/sample.tsv</p>
<p>Where /jobs/564759/sample.tsv would contain:</p>
<p>attr1tattr2tattr3tattr4
value1tvalue2tvalue3tvalue4
value5tvalue6tvalue7tvalue8</p>
<p>Array[Object] serialization using write_json()</p>
<p>🐖 Coming soon in Cromwell</p>
<p>an Array[Object] can be serialized using write_json() into a JSON file:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><p class="first">Array[Object] sample
command {</p>
<blockquote>
<div>perl script.pl ${write_json(sample)}</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>if sample is provided as:
Index   Attribute       Value
0       attr1   value1</p>
<blockquote>
<div>attr2   value2
attr3   value3
attr4   value4</div></blockquote>
<dl class="docutils">
<dt>1       attr1   value5</dt>
<dd>attr2   value6
attr3   value7
attr4   value8</dd>
</dl>
<p>Then, the resulting command line could look like:</p>
<p>perl script.pl /jobs/564759/sample.json</p>
<p>Where /jobs/564759/sample.json would contain:</p>
<dl class="docutils">
<dt>[</dt>
<dd><dl class="first docutils">
<dt>{</dt>
<dd>“attr1”: “value1”,
“attr2”: “value2”,
“attr3”: “value3”,
“attr4”: “value4”</dd>
</dl>
<p>},
{</p>
<blockquote>
<div>“attr1”: “value5”,
“attr2”: “value6”,
“attr3”: “value7”,
“attr4”: “value8”</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>]</p>
<p>De-serialization of Task Outputs</p>
<p>🐖 Cromwell supported ✅</p>
<p>A task’s command can only output data as files. Therefore, every de-serialization function in WDL takes a file input and returns a WDL type
Primitive Types</p>
<p>🐖 Cromwell supported ✅</p>
<p>De-serialization of primitive types is done through a read_* function. For example, read_int(“file/path”) and read_string(“file/path”).</p>
<p>For example, if I have a task that outputs a String and an Int:</p>
<dl class="docutils">
<dt>task output_example {</dt>
<dd><p class="first">String param1
String param2
command {</p>
<blockquote>
<div>python do_work.py ${param1} ${param2} –out1=int_file –out2=str_file</div></blockquote>
<p>}
output {</p>
<blockquote>
<div>Int my_int = read_int(“int_file”)
String my_str = read_string(“str_file”)</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>}</p>
<p>Both files file_with_int and file_with_uri should contain one line with the value on that line. This value is then validated against the type of the variable. If file_with_int contains a line with the text “foobar”, the workflow must fail this task with an error.
Compound Types</p>
<p>🐖 Cromwell supported ✅</p>
<p>Tasks can also output to a file or stdout/stderr an Array, Map, or Object data structure in a two major formats:</p>
<blockquote>
<div>JSON - because it fits naturally with the types within WDL
Text based / TSV - These are usually simple table and text-based encodings (e.g. Array[String] could be serialized by having each element be a line in a file)</div></blockquote>
<p>Array deserialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Maps are deserialized from:</p>
<blockquote>
<div>Files that contain a JSON Array as their top-level element.
Any file where it is desirable to interpret each line as an element of the Array.</div></blockquote>
<p>Array deserialization using read_lines()</p>
<p>🐖 Cromwell supported ✅</p>
<p>read_lines() will return an Array[String] where each element in the array is a line in the file.</p>
<p>This return value can be auto converted to other Array types. For example:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd><p class="first">python &lt;&lt;CODE
import random
for i in range(10):</p>
<blockquote>
<div>print(random.randrange(10))</div></blockquote>
<p class="last">CODE</p>
</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Array[Int] my_ints = read_lines(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>my_ints would contain ten random integers ranging from 0 to 10.
Array deserialization using read_json()</p>
<p>🐖 Coming soon in Cromwell</p>
<p>read_json() will return whatever data type resides in that JSON file</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd>echo ‘[“foo”, “bar”]’</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Array[String] my_array = read_json(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>This task would assign the array with elements “foo” and “bar” to my_array.</p>
<p>If the echo statement was instead echo ‘{“foo”: “bar”}’, the engine MUST fail the task for a type mismatch.
Map deserialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Maps are deserialized from:</p>
<blockquote>
<div>Files that contain a JSON Object as their top-level element.
Files that contain a two-column TSV file.</div></blockquote>
<p>Map deserialization using read_map()</p>
<p>🐖 Cromwell supported ✅</p>
<p>read_map() will return an Map[String, String] where the keys are the first column in the TSV input file and the corresponding values are the second column.</p>
<p>This return value can be auto converted to other Map types. For example:</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd><p class="first">python &lt;&lt;CODE
for i in range(3):</p>
<blockquote>
<div>print(“key_{idx}t{idx}”.format(idx=i)</div></blockquote>
<p class="last">CODE</p>
</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Map[String, Int] my_ints = read_map(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>This would put a map containing three keys (key_0, key_1, and key_2) and three respective values (0, 1, and 2) as the value of my_ints
Map deserialization using read_json()</p>
<p>🐖 Coming soon in Cromwell</p>
<p>read_json() will return whatever data type resides in that JSON file. If that file contains a JSON object with homogeneous key/value pair types (e.g. string -&gt; int pairs), then the read_json() function would return a Map.</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd>echo ‘{“foo”:”bar”}’</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Map[String, String] my_map = read_json(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>This task would assign the one key-value pair map in the echo statement to my_map.</p>
<p>If the echo statement was instead echo ‘[“foo”, “bar”]’, the engine MUST fail the task for a type mismatch.
Object deserialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Objects are deserialized from files that contain a two-row, n-column TSV file. The first row are the object attribute names and the corresponding entries on the second row are the values.
Object deserialization using read_object()</p>
<p>🐖 Cromwell supported ✅</p>
<p>read_object() will return an Object where the keys are the first row in the TSV input file and the corresponding values are the second row (corresponding column).</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd>python &lt;&lt;CODE
print(‘t’.join([“key_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
CODE</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Object my_obj = read_object(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>This would put an object containing three attributes (key_0, key_1, and key_2) and three respective values (value_0, value_1, and value_2) as the value of my_obj
Array[Object] deserialization</p>
<p>🐖 Cromwell supported ✅</p>
<p>Array[Object] MUST assume that all objects in the array are homogeneous (they have the same attributes, but the attributes don’t have to have the same values)</p>
<p>An Array[Object] is deserialized from files that contains at least 2 rows and a uniform n-column TSV file. The first row are the object attribute names and the corresponding entries on the subsequent rows are the values
Object deserialization using read_objects()</p>
<p>🐖 Cromwell supported ✅</p>
<p>read_object() will return an Object where the keys are the first row in the TSV input file and the corresponding values are the second row (corresponding column).</p>
<dl class="docutils">
<dt>task test {</dt>
<dd><dl class="first docutils">
<dt>command &lt;&lt;&lt;</dt>
<dd>python &lt;&lt;CODE
print(‘t’.join([“key_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
print(‘t’.join([“value_{}”.format(i) for i in range(3)]))
CODE</dd>
</dl>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">output {</span>
<span class="go">  Array[Object] my_obj = read_objects(stdout())</span>
<span class="go">}</span>
</pre></div>
</div>
</dd>
</dl>
<p>}</p>
<p>This would create an array of three identical Objects containing three attributes (key_0, key_1, and key_2) and three respective values (value_0, value_1, and value_2) as the value of my_obj</p>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, lidanqing

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>